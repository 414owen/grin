IR:
  X data Analysis = PointsTo | CreatedBy
  X new Constant value: CProducer Int
  - add reduction step for CProducer
  X change mapping of registers: (Name of variable, Name of analysis) -> Reg
  X change mapping of funArgs_ (Name of function, Name of analysis) -> (Reg, [Reg])
  - change reg mappings to records
CodeGen:
  - modify insertions function for reg mappings
  X add ReaderT [Analysis] layer to CG
  X modify run for the CG monad
  - modify getOrAddFunregs, so that it will get the analysis as a parameter as well
  - modify all call sites as well
  - add utility function getOrAddAllFunRegs :: Name -> Int -> CG ([IR.Reg], [[IR.Reg]]), this will make emits more mappable
  X modify addReg :: Name -> Analysis -> IR.Reg -> CG ()
  X modify all relevant call sites (whenever a new variable is bound, a register is introduced for it for each analysis)
  X same for getReg
  - modify getRegs
  ? modify call sites accordingly
  X emit' :: (Analysis -> [Instruction]) -> CG ()
    use: emit' \case
           PointsTo -> ...
           CreatedBy -> ...
  - helper function for generating a register for each individual analysis
    - more precisely a mapping from analysis name to register
  X have to change R ctor of Result to R (Map Analysis Reg)
  - modify all construction sites as well
  - introduce helper functions for emitting instructions for (analysis, regMapping) pairs (it would select the appropriate registers)
    - probably introduce new data type for this to keep the readability of the code (record syntax is easier to read)

analysis:
  - preconditions: - run after node naming
                   - run before case simplification (currently run before all simplyfing transformations - except node naming)
                   - run before any dead code elimination
  - cata -> para
  - Val: Var -> getReg
         _   -> do nothing (values don't have producers)
  - ProgramF: same
  - DefF: same, but if result is Z of the body, do nothing
  - EBindF:
    leftExp was Val:
      introduce a new producer with the name of variable inside the binding
    general case:
      Z -> same, just Move in case of Var lpat
      R -> after reg intro, only Vars van be on the RHS of a bind (this case is OK)

questions:
  - Does codeGenVal fail after register introduction? (and on ValTags as well)
    - define ValTag case: CNodeItem tag 0 _ (the 0th item of a node is its tag, its type is "tag" - does not really matter)
    - define VarTag case: - use current number of arguments as arity?
                          -
  - Can case alternatives have differently typed return values? (Lit <-> Node)
  - can a tag be applied to different number of arguments?
  - completely define Extend interpretation
  - define new Selector: AllTags Int (which selects the nth field of all tags, and unions all information about them)
  - We need tag information (arity) during the analysis to define codeGenVal for VarTag
    - create all possible


does bind normalisation work as intended?

  > nameNodes . parseExpr $ "y <- pure (t x)\npure y"
  EBind (EBind (SReturn (VarTagNode "t" [Var "x"])) (Var "node.0") (SReturn (Var "node.0"))) (Var "y") (SReturn (Var "y"))
  > bindNormalisation . nameNodes . parseExpr $ "y <- pure (t x)\npure y"
  EBind (EBind (SReturn (VarTagNode "t" [Var "x"])) (Var "node.0") (SReturn (Var "node.0"))) (Var "y") (SReturn (Var "y"))

modifications:
  - whenever a new variable is bound, a register is introduced for it for each analysis

bind normalisation: cata . ana // hylo
