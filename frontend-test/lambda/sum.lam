upto m n =
  let cmp = int_gt m n
  case cmp of
    (True)  -> (Nil)
    (False) -> let box1 = (Int 1)
                   succ = int_add m box1
                   tail = upto succ n
               (Cons m tail)

sum l =
  case l of
    (Nil)       -> (Int 0)
    (Cons n ns) -> let s = sum ns
                   int_add n s

main =
  let box1 = (Int 1)
      box2 = (Int 100000)
      l = upto box1 box2
      s = sum l
  int_print s

-- lazy boxed int built-in operations

int_add a b =
  case a of
    (Int x) -> case b of
                (Int y) -> letS z = _prim_int_add x y
                           (Int z)

int_gt a b =
  case a of
    (Int x) -> case b of
                (Int y) -> letS cmp = _prim_int_gt x y
                           case cmp of
                            #True   -> (True)
                            #False  -> (False)


int_print a =
  case a of
    (Int x) -> letS res = _prim_int_print x
               (Unit)
