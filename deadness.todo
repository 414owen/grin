We need a more intelligent deadness analysis that can resolve dependencies between variables.

The analysis should be run after sparse case eliminatio (so there will be no unreachable case alternatives).

Still context insensitive

x :-> y means: x is used if y is used
x :~> y means: x is used if y is used, but x can not necessarily be eliminated because of some side effect
x :-> {y,z} means: x is used if y and z are both used

x ==> <action> means: if x is used, perform <action> (an IF block in terms of code generation)

f[n]    means: the nth argumenth of f
f[ret]  means: the return register of is used
loc p   means: the heap location pointed to by p
res <e> means: the result register of <e>
R       means: scrutinized expression result register

f is used <=> f[ret] is used




Function definition:
f a b = <body>
f ==> analyze <body>
Will only generate liveness info for f[i] if f[ret] is used some somewhere.
This means, if the functions return value is never used, then all of its parameters are dead as well.



Bind:
Tag a b <- <lhs>
<rhs>
analyze <rhs>
analyze <lhs>
res <lhs> :-> a
res <lhs> :-> b

t a b <- <lhs>
<rhs>
analyze <rhs>
analyze <lhs>
res <lhs> :-> a
res <lhs> :-> b
res <lhs> :-> t


Case:
case x of
  CNode0 a0 b0 -> <alt0>
  CNode1 a1 b1 -> <alt1>
x :-> R
R ==> analyze <alt0>
R ==> analyze <alt1>
res <alt0> :-> R
res <alt1> :-> R


Application (context insensitive approach):
f a b
a :-> f[0]
b :-> f[1]


Store:
store x
x :~> loc R


Fetch:
fetch p
loc p :-> R


Update:
update p x
x :~> loc p


Pprimops:
_prim_int_print x
x is used

primop a b
a :-> R
b :-> R
We assume that primop[n] is always used for every n
